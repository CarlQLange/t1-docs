# Pins

GPIO access exists on the hardware interface.


array<number> hardware.digital = []
An array of which pins are digital inputs/outputs.

array<number> hardware.analog = []
An array of which pins are analog inputs/outputs.

array<number> hardware.pwm = []
An array of which pins are PWM outputs (may overlap analog array).


new hardware.Pin ( `pin`, `dir` or `initialOutput`, `edge` )
Create and return `pin` object.

string pin.type
"digital" or "analog".

boolean pin.isPWM
Whether the `pin.type` is set to `"analog"` and output type is PWM (thus not true analog).

boolean pin.readable
Whether the pin is readable.

boolean pin.writeable
Whether the pin is writeable.

number pin.resolution
Digital pins: 1. Analog pins: ADC resolution of output pins (e.g. 1024 for Tessel).

string pin.direction
"output" or "input".

pin.setInput( [`callback(err)`] )
Set `pin` to be an input. Sets `err` if the pin cannot be used as an input. 

pin.setOutput ( [`initial`], [callback(err)] ) 
Set `pin` to be an output. Sets `err` if the pin cannot be used as an output.  


pin.write ( `value`, [`callback(err)`] ) 
Write the `value` to an output pin. Digital pins: output is set HIGH if `value` is truthy, otherwise LOW. Analog pins: `value` is a float that sets the analog output value. Sets `err` if the pin cannot be used as a digital output or is not configured as an output.

pin.writeSync ( `value` )
Synchronous version of `pin.write`. Throws on error.

pin.read ( `callback(err, value)` ) 
Read a digital `value` from a digital input pin. `1` is returned if the value is HIGH, otherwise `0` if LOW. Sets `err` if the pin cannot be used as a digital input or is not configured as an input. An error is given to the callback if the pin cannot be used as a digital input or is not configured as an input.

pin.readSync () -> number
Synchronous version of `pin.read`. Throws on error.


pin.watchRise ( `onrise(err, time)` )  
Sets a listener for a rising signal edge on `pin`.

pin.unwatchRise ( )  
Removes the listener for rising signal edge.

pin.watchFall ( `onfall(err, time)` )  
Sets a listener for a falling signal edge on `pin`.

pin.unwatchFall ( )  
Removes the listener for the falling signal edge.


# SPI

A SPI channel.

new hardware.SPI ( [`idx`] )  
Creates a SPI channel.


spi.initialize (`onconnected(err)`)  
Initializes the SPI channel.


spi.setClockSpeed ( `mhz`, [`callback(err)`] ) 
Set the SPI output speed.  

spi.setCPOL ( `cpol`, [`callback(err)`] ) 
Set CPOL (SPI polarity).  

spi.setCPHA ( `cpha`, [`callback(err)`] ) 
Set CPHA (SPI bit significance).    


spi.transfer ( txbuf, callback(err, rxbuf) )
Transfers a Buffer `txbuf` to the client and receives a response in `rxbuf`.

spi.transferSync ( txbuf ) -> Buffer
Synchronous version of `spi.transfer`. Throws on error.

spi.receive ( len, callback(err, rxbuf) ) 
Reads `len` bytes from a client.

spi.receiveSync ( len ) -> Buffer
Synchronous version of `spi.receive`. Throws on error.

spi.send ( txbuf, callback(err) ) 
Sends a Buffer `txbuf` to the client.

spi.sendSync ( txbuf )
Synchronous version of `spi.send`. Throws on error.


# I2C

An I2C channel.

new hardware.I2C ( [`idx`] )  
Creates an I2C channel.


i2c.initialize ( `onconnected(err)` )  
Initializes the I2C channel.


i2c.transfer ( `address`, `writebuf`, `readcount`, `callback(err, data)` )  
Transfers the array of bytes `writebuf` to the device signified by `address` with `readcount` bytes.

i2c.read ( `address`, `readcount`, `callback(err, data)` )  
Reads `readcount` bytes from the device with the `address` on the bus.

i2c.write ( `address`, `writebuf`, `callback(err)` )  
Writes the array of bytes `writebuf` to the device with the `address` on the bus.


# UART

A UART channel.

new hardware.UART ( [`idx`[, `options`]] )
Creates a UART channel. Defaults: `{"baudrate": 9600, "dataBits": 8, "parity": "even", "stopBits": 2}`


array<number> uart.baudRates 
An array of valid baud rates supported by the system.  


uart.initialize ( `onconnected(err)` ) 
Initializes the UART connection.  

uart.setBaudRate ( `rate`, `callback(err)` ) 
Sets the baud `rate` to a valid rate in `baudRates`.

uart.setDataBits ( `bits`, `callback(err)` ) 
Sets the number of data `bits` to the number 5, 6, 7, or 8.

uart.setStopBits ( `bits`, `callback(err)` ) 
Sets the number of data `bits` to the number 1 or 2.

uart.setParity ( `parity`, `callback(err)` ) 
Sets the `parity` to the value "none", "odd", or "even".


uart.setDataListener ( `ondata(err, data)` ) 
Set the new data listener function.  

uart.removeDataListener 
Removes datas listener attached to the port.  

uart.write ( `buf`, `callback(err)` ) 
Writes a buffer to the UART connection.


# Signal

Signal output via buffers and simple animation protocols. High speed signals are implementation-dependent and use their own signal indexing scheme.

new hardware.Signal ( `interface`, `signalidx` )  
Creates a signal channel.

number signal.maxSpeed
The maximum speed (in MHz) at which a signal can be emitted.

number signal.idleBit = 0 
The bit, truthy for HIGH and otherwise LOW, to be output while there is no signal. This value is writeable.  


signal.initialize ( `onconnected(err)` ) 
Initializes the signal connection.

signal.setClockSpeed ( `MHz`, [`callback(err)`] ) 
Set the signal output speed from `0` to `maxSpeed`.  

signal.stop ( [`callback(err)`] ) 
Stop an ongoing signal.  

signal.loop ( `buf`, [`onrepeat(err)`] ) 
Repeat the buffered signal.  

signal.send ( `buf`, [`onfinished(err)`] ) 
Send a signal, calling the callback when completed.  

signal.queue ( `buf`, [`onfinished(err)`] ) 
Queue a signal for when the current signal completes.  