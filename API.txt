# Pins

GPIO access exists on the hardware interface.


array<number> hardware.digitalReadPins = []
An array of which pins are digital inputs.

array<number> hardware.digitalWritePins = []
An array of which pins are digital outputs.

array<number> hardware.analogReadPins = []
An array of which pins are analog inputs.

array<number> hardware.analogWritePins = []
An array of which pins are analog outputs.

array<number> hardware.pwmWritePins = []
An array of which pins are PWM outputs.


new hardware.Pin ( `pin` )
Create and return `pin` object.

array<number> pin.setInput( [`callback(err)`] )
Set `pin` to be an input. Sets `err` if the pin cannot be used as an input. 

pin.setOutput ( [`initial`], [`callback(err)`] ) 
Set `pin` to be an output. Sets `err` if the pin cannot be used as an output.  


pin.write ( `value`, [`callback(err)`] ) 
Write the digital `value` to a digital output pin. HIGH is output if `value` is truthy, otherwise LOW. Sets `err` if the pin cannot be used as a digital output or is not configured as an output.

pin.read ( `callback(err, value)` ) 
Read a digital `value` from a digital input pin. `1` is returned if the value is HIGH, otherwise `0` if LOW. Sets `err` if the pin cannot be used as a digital input or is not configured as an input.  

pin.readSync () *&rarr; number* 
Reads a digital `value` from a digital input pin synchronously and returns immediately. `1` is returned if the value is HIGH, otherwise `0` if LOW. An error is thrown if the pin cannot be used as a digital input or is not configured as an input.  


pin.analogWrite ( `value`, [`callback(err)`] ) 
Write the analog `value` to an analog output pin. The `value` is a number ranging from `0` to `255`. Sets `err` if the pin cannot be used as an analog output or is not configured as an output.  

pin.analogRead ( `callback(err, value)` )  
Read the analog `value` from an analog input pin. The `value` is a number ranging from `0` to `1024`. Sets `err` if the pin cannot be used as an analog input or is not configured as an input.  

pin.analogReadSync () *&rarr; number*  
Read the analog `value` from an analog input pin synchronously and returns immediately. The `value` is a number ranging from `0` to `1024`. An error is thrown if the pin cannot be used as an analog input or is not configured as an input.  

pin.pwmWrite ( `value`, [`callback(err)`] ) 
Write the analog `value` to a PWM output pin. The `value` is a number ranging from `0` to `255`. Sets `err` if the pin cannot be used as an PWM output or is not configured as an output.  


pin.setRiseListener ( `onrise(err, time)` )  
Sets a listener for a rising signal edge on `pin`.

pin.removeRiseListener ( )  
Removes the listener for rising signal edge.

pin.setFallListener ( `onfall(err, time)` )  
Sets a listener for a falling signal edge on `pin`.

pin.removeFallListener ( )  
Removes the listener for the falling signal edge.


# SPI

A SPI channel.

new hardware.SPI ( [`idx`] )  
Creates a SPI channel.


spi.initialize (`onconnected(err)`)  
Initializes the SPI channel.


spi.setClockSpeed ( `mhz`, [`callback(err)`] ) 
Set the SPI output speed.  

spi.setCPOL ( `cpol`, [`callback(err)`] ) 
Set CPOL (SPI polarity).  

spi.setCPHA ( `cpha`, [`callback(err)`] ) 
Set CPHA (SPI bit significance).    


spi.transfer ( `cs`, `writebuf`, `readcount`, `callback(err, data)` ) 
`cs` is the chip select pin, or `-1` if no pin should be toggled.  

spi.read ( `cs`, `readcount`, `callback(err, data)` ) 
`cs` is the chip select pin, or `-1` if no pin should be toggled.  

spi.write ( `cs`, `writebuf`, `callback(err)` ) 
`cs` is the chip select pin, or `-1` if no pin should be toggled.  


# I2C

An I2C channel.

new hardware.I2C ( [`idx`] )  
Creates an I2C channel.


i2c.initialize ( `onconnected(err)` )  
Initializes the I2C channel.


i2c.transfer ( `address`, `writebuf`, `readcount`, `callback(err, data)` )  
Transfers the array of bytes `writebuf` to the device signified by `address` with `readcount` bytes.

i2c.read ( `address`, `readcount`, `callback(err, data)` )  
Reads `readcount` bytes from the device with the `address` on the bus.

i2c.write ( `address`, `writebuf`, `callback(err)` )  
Writes the array of bytes `writebuf` to the device with the `address` on the bus.


# UART

A UART channel.

new hardware.UART ( [`idx`] )
Creates a UART channel.


array<number> uart.baudRates 
An array of valid baud rates supported by the system.  


uart.initialize ( `onconnected(err)` ) 
Initializes the UART connection.  

uart.setBaudRate ( `rate`, `callback(err)` ) 
Sets the baud `rate` to a valid rate in `baudRates`.


uart.setDataListener ( `ondata(err, data)` ) 
Set the new data listener function.  

uart.removeDataListener 
Removes datas listener attached to the port.  

uart.write ( `buf`, `callback(err)` ) 
Writes a buffer to the UART connection.


# Signal

Signal output via buffers and simple animation protocols. High speed signals are implementation-dependent and use their own signal indexing scheme.

new hardware.Signal ( `interface`, `signalidx` )  
Creates a signal channel.

number signal.maxSpeed
The maximum speed (in MHz) at which a signal can be emitted.

number signal.idleBit = 0 
The bit, truthy for HIGH and otherwise LOW, to be output while there is no signal. This value is writeable.  


signal.initialize ( `onconnected(err)` ) 
Initializes the signal connection.

signal.setClockSpeed ( `MHz`, [`callback(err)`] ) 
Set the signal output speed from `0` to `maxSpeed`.  

signal.stop ( [`callback(err)`] ) 
Stop an ongoing signal.  

signal.loop ( `buf`, [`onrepeat(err)`] ) 
Repeat the buffered signal.  

signal.send ( `buf`, [`onfinished(err)`] ) 
Send a signal, calling the callback when completed.  

signal.queue ( `buf`, [`onfinished(err)`] ) 
Queue a signal for when the current signal completes.  