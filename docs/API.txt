# Tessel

You can import Tessel into your project by using `var tessel = require('tessel')`.

```js
var tessel = require('tessel'); // import tessel
var gpio = tessel.port['GPIO']; // select the GPIO port
gpio.digital[1].writeSync(1);  // turn digital pin #1 high
```


array<Port> tessel.port = []
A list of ports available on Tessel.

array<Pin> tessel.led = []
An array of Pins available on the Tessel board.


# Pins

GPIO access for digital and analog signal lines. Each port exposes its available GPIO lines through the `.pin`, `.digital`, `.analog`, and `.pwm` arrays.

```js
var tessel = require('tessel'); // import tessel
var gpio = tessel.port['GPIO']; // select the GPIO port
gpio.digital.map(function (pin, i) {
	console.log('Value of digital pin', i, '=', pin.readSync());
})
gpio.analog.map(function (pin, i) {
	console.log('Value of analog pin', i, '=', pin.readSync() * pin.resolution, '/', pin.resolution);
})
```


array<number> port.digital = []
An array of which pins are digital inputs/outputs.

array<number> port.analog = []
An array of which pins are analog inputs/outputs.

array<number> port.pwm = []
An array of which pins are PWM outputs (may overlap analog array).

array<number> port.pin = []
An array of all pins on the port. You can differentiate them by their `.type` and `.isPWM` attributes.


new port.Pin ( `pin`, `dir` or `initialOutput` )
Create and return `pin` object. If `dir` is "input" or "output", the direction is set to that value immediately. Otherwise, the pin is written to with the value of `initialOutput`. 

string pin.type
"digital" or "analog".

boolean pin.isPWM
Whether the `pin.type` is set to `"analog"` and output type is PWM (thus not true analog).

boolean pin.readable
Whether the pin is readable.

boolean pin.writeable
Whether the pin is writeable.

number pin.resolution
Digital pins: 1. Analog pins: ADC resolution of output pins (e.g. 1024 for Tessel).

string pin.direction
"output" or "input".

pin.setInput( [callback(err)] )
Set `pin` to be an input. Sets `err` if the pin cannot be used as an input. 

pin.setOutput ( [`initial`], [callback(err)] ) 
Set `pin` to be an output. Sets `err` if the pin cannot be used as an output.  


pin.write ( `value`, [`callback(err)`] ) 
Write the `value` to an output pin. Digital pins: output is set HIGH if `value` is truthy, otherwise LOW. Analog pins: `value` is a float that sets the analog output value. Sets `err` if the pin cannot be used as a digital output or is not configured as an output.

pin.writeSync ( `value` )
Synchronous version of `pin.write`. Throws on error.

pin.read ( `callback(err, value)` ) 
Read a digital `value` from a digital input pin. `1` is returned if the value is HIGH, otherwise `0` if LOW. Sets `err` if the pin cannot be used as a digital input or is not configured as an input. An error is given to the callback if the pin cannot be used as a digital input or is not configured as an input.

pin.readSync () -> number
Synchronous version of `pin.read`. Throws on error.


pin.watch ( [type,] callback(err, time) )  
Sets a listener for a signal edge on `pin`. `type` can be one of "rise", "fall", "both", or omitted (analogous to "both"). Watched events registers events on the `pin` object, with the same `type` as the event.

pin.unwatch ( [type,] listener )
Removes the listener for a signal.



# SPI

A SPI channel.

```js
var port = tessel.port['A'];
var spi = new port.SPI()
spi.setClockSpeed(4*1000*1000) // 4MHz
spi.setCPOL(1) // polarity
spi.setCPHA(0) // bit significance
spi.on('ready', function () {
	spi.transfer(new Buffer([0xde, 0xad, 0xbe, 0xef]), function (err, rx) {
		console.log('buffer returned by SPI slave:', rx);
	})
})
```

new port.SPI ( [idx,] [options] ) 
Creates a SPI channel. `idx` is an optional index for selecting a SPI port, defaulting to 0. (On Tessel, there is only one SPI channel per port.)


spi.setClockSpeed ( mhz, [callback(err)] ) 
Set the SPI output speed to the number `mhz`.

spi.setCPOL ( `cpol`, [`callback(err)`] ) 
Set CPOL (SPI polarity). 

spi.setCPHA ( `cpha`, [`callback(err)`] ) 
Set CPHA (SPI bit significance).


spi.transfer ( txbuf, [rxbuf,] callback(err, rxbuf) )
Transfers a Buffer `txbuf` to the client and receives a response in `rxbuf`. If `rxbuf` is passed in, it is used as the receive buffer. Otherwise, a new buffer is allocated.

spi.transferSync ( txbuf ) -> Buffer
Synchronous version of `spi.transfer`. Throws on error.

spi.receive ( len, [rxbuf,] callback(err, rxbuf) ) 
Reads `len` bytes from a client. If `rxbuf` is passed in, it is used as the receive buffer. Otherwise, a new buffer is allocated.

spi.receiveSync ( len ) -> Buffer
Synchronous version of `spi.receive`. Throws on error.

spi.send ( txbuf, callback(err) ) 
Sends a Buffer `txbuf` to the client.

spi.sendSync ( txbuf )
Synchronous version of `spi.send`. Throws on error.


# I2C

An I2C channel.

```js
var port = tessel.port['A'];
var slaveAddress = 0xDE;
var i2c = new port.I2C(slaveAddress)
i2c.on('ready', function () {
	i2c.transfer(new Buffer([0xde, 0xad, 0xbe, 0xef]), function (err, rx) {
		console.log('buffer returned by I2C slave ('+slaveAddress.toString(16)+'):', rx);
	})
})
```

new port.I2C ( address, [idx] )  
Creates an I2C channel for a device of a specific `address`. Multiple I2C channels can be used in parallel.


i2c.use ( `onconnected(err)` )  
Initializes the I2C channel.


i2c.transfer ( txbuf, [rxbuf,] callback(err, rxbuf) )
Transfers a Buffer `txbuf` to the client and receives a response in `rxbuf`. If `rxbuf` is passed in, it is used as the receive buffer. Otherwise, a new buffer is allocated.

i2c.transferSync ( txbuf ) -> Buffer
Synchronous version of `i2c.transfer`. Throws on error.

i2c.receive ( len, [rxbuf,] callback(err, rxbuf) ) 
Reads `len` bytes from a client. If `rxbuf` is passed in, it is used as the receive buffer. Otherwise, a new buffer is allocated.

i2c.receiveSync ( len ) -> Buffer
Synchronous version of `i2c.receive`. Throws on error.

i2c.send ( txbuf, callback(err) ) 
Sends a Buffer `txbuf` to the client.

i2c.sendSync ( txbuf )
Synchronous version of `i2c.send`. Throws on error.


# UART

A UART channel.

```js
var port = tessel.port['A'];
var uart = new port.UART({
	baudrate: 115200
})
uart.on('ready', function () {
	uart.write('ahoy hoy\n')
	uart.on('data', function (data) {
		console.log('received:', data);
	})

	// UART objects are streams!
	// pipe all incoming data to stdout:
	uart.pipe(process.stdout);
})
```

new port.UART ( [`idx`[, `options`]] ) implements DuplexStream
Creates a UART channel. Defaults: `{"baudrate": 9600, "dataBits": 8, "parity": "even", "stopBits": 2}`


array<number> uart.baudRates 
An array of valid baud rates supported by the system.  


uart.use ( `onconnected(err)` ) 
Initializes the UART connection.  

uart.setBaudRate ( `rate`, `callback(err)` ) 
Sets the baud `rate` to a valid rate in `baudRates`.

uart.setDataBits ( `bits`, `callback(err)` ) 
Sets the number of data `bits` to the number 5, 6, 7, or 8.

uart.setStopBits ( `bits`, `callback(err)` ) 
Sets the number of data `bits` to the number 1 or 2.

uart.setParity ( `parity`, `callback(err)` ) 
Sets the `parity` to the value "none", "odd", or "even".


uart emits "data"
Set the new data listener function.  

uart.write ( `buf`, `callback(err)` ) 
Writes a buffer to the UART connection.

uart.writeSync ( `buf` ) 
Synchronous version of `uart.write`. Throws on error.


# Signal [Not yet implemented]

Signal output via buffers and simple animation protocols. High speed signals are implementation-dependent and use their own signal indexing scheme.

new port.Signal ( `interface`, `signalidx` )  
Creates a signal channel.

number signal.maxSpeed
The maximum speed (in MHz) at which a signal can be emitted.

number signal.idleBit = 0 
The bit, truthy for HIGH and otherwise LOW, to be output while there is no signal. This value is writeable.  


signal.initialize ( `onconnected(err)` ) 
Initializes the signal connection.

signal.setClockSpeed ( `MHz`, [`callback(err)`] ) 
Set the signal output speed from `0` to `maxSpeed`.  

signal.stop ( [`callback(err)`] ) 
Stop an ongoing signal.  

signal.loop ( `buf`, [`onrepeat(err)`] ) 
Repeat the buffered signal.  

signal.send ( `buf`, [`onfinished(err)`] ) 
Send a signal, calling the callback when completed.  

signal.queue ( `buf`, [`onfinished(err)`] ) 
Queue a signal for when the current signal completes.  